# All-Reduce 基准测试结果

## 运行脚本

### 运行所有测试组合（推荐）

运行所有后端、进程数和数据大小的组合，并自动生成结果表格：

```bash
uv run python cs336_systems/parallel/all_reduce_benchmark.py --run_all
```

### 运行单个测试

测试特定配置：

```bash
# Gloo 后端，2 个进程，1MB 数据
uv run python cs336_systems/parallel/all_reduce_benchmark.py \
    --backend gloo \
    --world_size 2 \
    --data_size_mb 1.0

# NCCL 后端，4 个进程，100MB 数据
uv run python cs336_systems/parallel/all_reduce_benchmark.py \
    --backend nccl \
    --world_size 4 \
    --data_size_mb 100.0
```

### 自定义参数

```bash
uv run python cs336_systems/parallel/all_reduce_benchmark.py \
    --backend nccl \
    --world_size 6 \
    --data_size_mb 1000.0 \
    --num_warmup 5 \
    --num_iterations 10
```

### 参数说明

- `--backend`: 后端选择，`gloo`（CPU）或 `nccl`（GPU）
- `--world_size`: 进程数，可选 2、4、6
- `--data_size_mb`: 数据大小（MB），常用值：1.0, 10.0, 100.0, 1000.0
- `--num_warmup`: Warm-up 迭代次数（默认：5）
- `--num_iterations`: 测量迭代次数（默认：10）
- `--run_all`: 运行所有组合并生成表格

## 测试配置

- **Warm-up 步骤**: 5 次
- **测量步骤**: 10 次
- **数据精度**: float32
- **测试环境**: 单节点多进程

## 基准测试结果

| Backend | World Size | Data Size (MB) | Mean (ms) | Std (ms) | Min (ms) | Max (ms) |
|---------|-----------|----------------|-----------|----------|----------|----------|
| gloo    | 2         | 1.0            | 0.732     | 0.078     | 0.608    | 0.830    |
| gloo    | 2         | 10.0           | 5.171     | 0.611     | 4.496    | 5.851    |
| gloo    | 2         | 100.0          | 55.693    | 0.706     | 54.849   | 56.549   |
| gloo    | 2         | 1000.0         | 652.504   | 240.165   | 492.222  | 1292.361 |
| gloo    | 4         | 1.0            | 1.397     | 0.129     | 1.215    | 1.805    |
| gloo    | 4         | 10.0           | 10.904    | 0.690     | 9.474    | 12.400   |
| gloo    | 4         | 100.0          | 98.793    | 8.168     | 88.846   | 114.129  |
| gloo    | 4         | 1000.0         | 946.455   | 105.220   | 852.224  | 1204.524 |
| gloo    | 6         | 1.0            | 2.005     | 0.083     | 1.789    | 2.218    |
| gloo    | 6         | 10.0           | 16.271    | 1.184     | 14.117   | 18.313   |
| gloo    | 6         | 100.0          | 145.402   | 12.184    | 134.757  | 165.344  |
| gloo    | 6         | 1000.0         | 1090.784  | 149.475   | 934.539  | 1440.527 |
| nccl    | 2         | 1.0            | 0.099     | 0.013     | 0.084    | 0.136    |
| nccl    | 2         | 10.0           | 0.156     | 0.014     | 0.144    | 0.196    |
| nccl    | 2         | 100.0          | 0.772     | 0.028     | 0.721    | 0.797    |
| nccl    | 2         | 1000.0         | 6.280     | 0.064     | 6.173    | 6.384    |
| nccl    | 4         | 1.0            | 0.075     | 0.008     | 0.070    | 0.095    |
| nccl    | 4         | 10.0           | 0.219     | 0.015     | 0.202    | 0.255    |
| nccl    | 4         | 100.0          | 0.977     | 0.034     | 0.945    | 1.055    |
| nccl    | 4         | 1000.0         | 8.207     | 0.089     | 8.134    | 8.487    |
| nccl    | 6         | 1.0            | 0.085     | 0.006     | 0.076    | 0.095    |
| nccl    | 6         | 10.0           | 0.218     | 0.012     | 0.199    | 0.243    |
| nccl    | 6         | 100.0          | 1.077     | 0.044     | 1.022    | 1.149    |
| nccl    | 6         | 1000.0         | 8.846     | 0.096     | 8.666    | 9.198    |

## 结果分析

### 1. 后端性能对比（Gloo vs NCCL）

**NCCL 显著快于 Gloo**：
- **小数据（1MB）**: NCCL 比 Gloo 快约 **7-20 倍**
  - Gloo (2进程): 0.732 ms
  - NCCL (2进程): 0.099 ms（约 7.4 倍）
- **大数据（1GB）**: NCCL 比 Gloo 快约 **100-120 倍**
  - Gloo (2进程): 652.5 ms
  - NCCL (2进程): 6.28 ms（约 104 倍）

**原因分析**：
- NCCL 是 NVIDIA 优化的 GPU 通信库，针对 GPU 间通信进行了深度优化
- Gloo 是通用的通信库，主要用于 CPU 通信，在 GPU 上性能较差

### 2. 数据大小对性能的影响

**Gloo (CPU)**：
- 数据大小与时间大致呈线性关系
- 1MB → 10MB: 约 7 倍时间增加
- 10MB → 100MB: 约 10 倍时间增加
- 100MB → 1GB: 约 10 倍时间增加（但标准差较大，说明不稳定）

**NCCL (GPU)**：
- 数据大小与时间大致呈线性关系，但更稳定
- 1MB → 10MB: 约 1.5-2 倍时间增加
- 10MB → 100MB: 约 5 倍时间增加
- 100MB → 1GB: 约 8-10 倍时间增加
- 标准差很小，说明性能非常稳定

### 3. 进程数对性能的影响

**Gloo (CPU)**：
- 进程数增加，通信时间显著增加
- 2进程 → 4进程: 时间增加约 1.5-2 倍
- 4进程 → 6进程: 时间增加约 1.1-1.5 倍
- 说明 CPU 通信的扩展性较差

**NCCL (GPU)**：
- 进程数增加，通信时间略有增加或基本不变
- 2进程 → 4进程: 时间变化很小（甚至可能减少，因为更好的并行性）
- 4进程 → 6进程: 时间略有增加（约 10-20%）
- 说明 GPU 通信的扩展性较好

### 4. 性能稳定性

**Gloo (CPU)**：
- 小数据（1-100MB）: 标准差较小，性能稳定
- 大数据（1GB）: 标准差较大（特别是 2 进程时达到 240 ms），说明性能不稳定

**NCCL (GPU)**：
- 所有数据大小下标准差都很小（< 0.1 ms），说明性能非常稳定
- 这是 GPU 硬件和 NCCL 优化的结果

## 主要发现

1. **NCCL 在 GPU 上性能远优于 Gloo**，特别是在大数据传输时
2. **NCCL 的性能更稳定**，标准差小
3. **NCCL 的扩展性更好**，进程数增加时性能下降较小
4. **Gloo 适合 CPU 通信和本地开发**，但在 GPU 上性能较差
5. **数据大小与通信时间大致呈线性关系**，符合预期

## 建议

- **GPU 训练**: 始终使用 NCCL 后端
- **CPU 训练/本地开发**: 使用 Gloo 后端
- **大规模数据传输**: NCCL 的优势更加明显
- **多进程通信**: NCCL 的扩展性更好

